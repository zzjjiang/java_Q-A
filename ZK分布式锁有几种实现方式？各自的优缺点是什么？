Zk分布式锁有两种实现方式
一种比较简单，应对并发量不是很大的情况。
获得锁：创建一个临时节点，比如/lock，如果成功获得锁，如果失败没获得锁，返回false
释放锁：删除/lock节点
锁等待：使用监听机制，监听lock节点，如果lock节点被删除，重新去抢锁，否则一直等待

第二种方式，这种方式比第一种复杂点，但解决了羊群效应问题。
获得锁：创建临时带序号的节点，排序，判断创建的节点是否是当前目录下最小的，如果最小获得锁结束
如果不是，获得当前节点的前面一个节点名称，进入锁等待
释放锁：删除创建的临时带序号节点
锁等待：获取第一步的获的前一个节点名称，使用监听机制，监听这节点，当这个节点被删除的时候，重新去抢锁

https://www.bilibili.com/video/BV1wp4y1X7c4?from=search&seid=16330532071376900042    张富刚老师-深入剖析基于zk的分布式锁的实现
