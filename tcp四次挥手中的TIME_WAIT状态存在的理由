用A表示tcp连接的主动关闭端， 用B表示被动关闭端。

        我们知道， 在tcp四次挥手中， B发FIN包（第三次挥手）后， A马上回应最后的ACK,  此时， A的socket让然不能立即进入CLOSED的状态， 为什么呢？ 其实这就是在问TIME_WAIT状态存在的理由。

        理由之一：

        A不能保证最后的ACK能达到B， 所以， 还应该观望一段时间， 护送一段时间。 如果最后的ACK丢失， 那么B显然收不到,  B于是发起了重传FIN的操作， 此时如果A处于CLOSED的状态， 就没办法给对端发ACK了（实际是发RST）， 呜呼哀哉。 所以A应该等一段时间， 这段时间就是所谓的TIME_WAIT， 比如， 等待一个RTT的时间（实际上， 考虑到如下的理由之二就知道， RTT可能不够， 用2MSL更靠谱）。

       所以， TIME_WAIT存在的理由之一是尽可能护送最后的ACK达到对端。



        理由之二：

        假设tcp连接是： A(1.2.3.4:8888)------B(6.7.8.9:9999), 这就是一个tcp四元组。 当tcp连接关闭后， 四元组释放。 后面的新连接可能会重用到这个四元组（有这个可能性）， 那么问题就来了： 新四元组和旧四元组完全一致， 他们的网络包会混乱吗？   所以， 可以考虑这样一个机制： 让旧四元组对应的所有网络包都消失后（等一段时间）， 才允许新四元组建立， 颇有点锁的味道。 那么这个等一段时间究竟是多久呢？ 多久才合适呢？ 在前面的文章中， 我们讨论过， 采用2MSL比较合适， 我个人认为， 把TIME_WAIT定义为2MSL只是一个通用的经验方法而已， 无法从理论上百分之百论证。

        所以， TIME_WAIT存在的理由之二是新旧四元组互不干扰。
